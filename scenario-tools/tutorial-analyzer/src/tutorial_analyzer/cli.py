"""CLI wrapper around tutorial analysis pipeline.

This is a STUD (interface):
- Wraps pipeline.py with CLI-specific I/O
- Console progress (print statements)
- Console approval (input() blocking)
- Local file state (.tutorial_analyzer_state.json)

Philosophy:
- Thin wrapper: Delegates to pipeline, handles only I/O
- CLI-specific policy: How to display, how to get approval
- Unchanged UX: Works exactly as before
"""

import asyncio
import sys
from pathlib import Path

from .pipeline import run_analysis_pipeline
from .state import load_state
from .state import save_state


def _generate_report(state: dict, tutorial_path: Path, report_path: Path) -> None:
    """Generate comprehensive markdown analysis report."""
    with open(report_path, "w", encoding="utf-8") as f:
        f.write("# Tutorial Analysis Report\n\n")
        f.write(f"**Tutorial:** `{tutorial_path.name}`\n")
        f.write(f"**Quality Score:** {state.get('synthesis', {}).get('quality_score', 'N/A')}\n\n")
        f.write("---\n\n")

        # Diagnosis Summary
        if "diagnosis" in state:
            f.write("## Diagnosis Summary\n\n")
            diagnosis = state["diagnosis"]
            if "summary" in diagnosis:
                summary = diagnosis["summary"]
                f.write(f"**Primary Issue:** {summary.get('primary_pedagogical_failure', 'N/A')}\n\n")
                f.write(
                    f"**Issues Found:** {summary.get('critical_issues', 0)} critical, "
                    f"{summary.get('major_issues', 0)} major, {summary.get('minor_issues', 0)} minor\n\n"
                )

            # Detailed issues
            if "issues" in diagnosis and isinstance(diagnosis["issues"], list):
                f.write("### Identified Issues\n\n")
                for issue in diagnosis["issues"]:
                    if isinstance(issue, dict):
                        severity = issue.get("severity", "unknown").upper()
                        f.write(f"- **[{severity}]** {issue.get('issue', 'Unknown issue')}\n")
                f.write("\n")

        # Learner Experience
        if "learner_experience" in state:
            f.write("## From Learner Perspective\n\n")
            exp = state["learner_experience"]
            if isinstance(exp, dict):
                if "issue" in exp:
                    f.write(f"**Confusion Point:** {exp['issue']}\n\n")
                if "location" in exp:
                    f.write(f"**Location:** {exp['location']}\n\n")
            f.write("\n")

        # Improvements
        if "improvements" in state:
            f.write("## Recommended Improvements\n\n")
            improvements_data = state["improvements"]

            # Handle single improvement object
            if "title" in improvements_data and "description" in improvements_data:
                suggestions = [improvements_data]
            else:
                suggestions = improvements_data.get("suggestions") or improvements_data.get("improvements", [])

            if isinstance(suggestions, list):
                for i, suggestion in enumerate(suggestions, 1):
                    if isinstance(suggestion, dict):
                        f.write(f"### {i}. {suggestion.get('title', 'Untitled')}\n\n")
                        f.write(f"{suggestion.get('description', 'No description')}\n\n")
                        if "location" in suggestion:
                            f.write(f"**Location:** {suggestion.get('location')}\n\n")
                    else:
                        f.write(f"### {i}. {suggestion}\n\n")

        # Implementation Priority
        if "synthesis" in state:
            f.write("## Implementation Priority\n\n")
            synthesis = state["synthesis"]
            recommendations = synthesis.get("recommendations", [])
            if isinstance(recommendations, list):
                for i, rec in enumerate(recommendations, 1):
                    f.write(f"{i}. {rec}\n")
            f.write("\n")

        f.write("---\n\n")
        f.write("*Generated by tutorial-analyzer using Multi-Config Metacognitive Recipe Pattern*\n")


async def evolve_tutorial(tutorial_path: Path, focus_areas: list[str] | None = None):
    """CLI wrapper for tutorial evolution.

    Args:
        tutorial_path: Path to tutorial markdown file
        focus_areas: Optional list of areas to focus on (e.g., ["clarity", "examples"])

    Returns:
        Dict with final results: {report_path, quality_score}
    """

    # CLI reads file
    content = tutorial_path.read_text()

    # CLI uses local state
    state = load_state()

    # Add focus_areas to state so pipeline can access
    if focus_areas:
        state["focus_areas"] = focus_areas

    # CLI-specific progress callback
    def progress(msg: str) -> None:
        print(msg)

    # CLI-specific approval callback
    async def request_approval(context: dict) -> dict:
        print("\n" + "=" * 60)
        print("PROPOSED IMPROVEMENTS:")
        print("=" * 60)

        # Display improvements (defensive: handle multiple formats)
        improvements_data = context["improvements"]

        # Handle if LLM returned single improvement instead of array
        if "title" in improvements_data and "description" in improvements_data:
            # Single improvement object - wrap in array
            suggestions = [improvements_data]
        else:
            # Look for suggestions array
            suggestions = improvements_data.get("suggestions") or improvements_data.get("improvements", [])

        if isinstance(suggestions, list) and len(suggestions) > 0:
            for i, improvement in enumerate(suggestions, 1):
                if isinstance(improvement, dict):
                    print(f"\n{i}. {improvement.get('title', 'Untitled')}")
                    print(f"   {improvement.get('description', 'No description')}")
                else:
                    print(f"\n{i}. {improvement}")
        else:
            print("\n[No improvements found in response]")
            print(f"Received: {list(improvements_data.keys())}")

        print("=" * 60)

        approval = input("\nApprove these improvements? (yes/no/modify): ").lower()

        if approval == "modify":
            modifications = input("What modifications? ")
            return {"decision": approval, "modifications": modifications}

        return {"decision": approval}

    # Run pipeline with CLI callbacks
    result = await run_analysis_pipeline(
        content=content,
        state=state,
        on_save_state=save_state,  # Uses local .json file
        on_progress=progress,
        on_request_approval=request_approval,
    )

    # Check if rejected
    if result.get("status") == "rejected":
        return result

    # CLI-specific: Generate report file
    print("\nStage 7/7: Generating analysis report...")
    report_path = Path.cwd() / f"{tutorial_path.stem}_analysis.md"
    _generate_report(result, tutorial_path, report_path)
    print(f"‚úì Report saved to: {report_path}")

    print("\n‚úì Tutorial analysis complete!")
    return {"report_path": str(report_path), "quality_score": result["synthesis"]["quality_score"]}


def cli():
    """CLI entry point.

    Usage:
        tutorial-analyzer <tutorial.md> [focus_area1] [focus_area2] ...

    Example:
        tutorial-analyzer tutorial.md clarity examples
    """
    if len(sys.argv) < 2:
        print("Usage: tutorial-analyzer <tutorial.md> [focus_area1] [focus_area2] ...")
        print("\nExamples:")
        print("  tutorial-analyzer tutorial.md")
        print("  tutorial-analyzer tutorial.md clarity examples code-quality")
        sys.exit(1)

    tutorial_path = Path(sys.argv[1])
    focus_areas = sys.argv[2:] if len(sys.argv) > 2 else None

    # Validate input
    if not tutorial_path.exists():
        print(f"Error: {tutorial_path} does not exist")
        sys.exit(1)

    if not tutorial_path.is_file():
        print(f"Error: {tutorial_path} is not a file")
        sys.exit(1)

    # Run
    result = asyncio.run(evolve_tutorial(tutorial_path, focus_areas))

    # Report
    if result.get("status") == "rejected":
        print(f"\n‚ùå Process stopped: {result.get('reason')}")
        sys.exit(1)
    else:
        print(f"\n‚úÖ Final quality score: {result.get('quality_score', 'N/A')}")
        print(f"üìÑ Analysis report: {result.get('report_path', 'N/A')}")


if __name__ == "__main__":
    cli()
